<template>
  <div class="border rounded-lg p-6 shadow-sm hover:shadow-md transition-shadow">
    <div class="flex items-start justify-between mb-4">
      <div>
        <h3 class="text-xl font-semibold mb-2">{{ title }}</h3>
        <p class="text-gray-600 mb-2">{{ description }}</p>
        <code class="text-sm bg-gray-100 px-2 py-1 rounded">
          {{ method }} {{ endpoint }}
        </code>
      </div>
      <div class="text-right">
        <div class="text-sm text-gray-500">Price</div>
        <div class="text-lg font-bold">
          {{ price === "0" ? "FREE" : `${price} USDC` }}
        </div>
      </div>
    </div>

    <button
      v-if="!paymentRequired"
      @click="handleFetch()"
      :disabled="loading"
      class="w-full bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
    >
      {{ loading ? "Loading..." : "Try Endpoint" }}
    </button>

    <div v-if="paymentRequired" class="space-y-4">
      <div class="bg-yellow-50 border border-yellow-200 rounded p-4">
        <div class="text-sm font-semibold text-yellow-800 mb-2">üí≥ Payment Required</div>
        <div class="text-sm text-yellow-700 space-y-1">
          <p><strong>Amount:</strong> {{ paymentRequired.max_amount_required }} {{ paymentRequired.asset_type }}</p>
          <p><strong>Recipient:</strong> <code class="text-xs bg-yellow-100 px-1 py-0.5 rounded">{{ paymentRequired.payment_address.slice(0, 8) }}...{{ paymentRequired.payment_address.slice(-4) }}</code></p>
          <p><strong>Network:</strong> {{ paymentRequired.network }}</p>
          <p><strong>Expires:</strong> {{ new Date(paymentRequired.expires_at).toLocaleString() }}</p>
        </div>
      </div>

      <div class="space-y-2">
        <button
          @click="handleSimulatePayment"
          :disabled="loading"
          class="w-full bg-green-600 text-white py-2 px-4 rounded hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
        >
          {{ loading ? "Processing..." : "Simulate Payment & Retry" }}
        </button>
        <button
          @click="handleCancel"
          class="w-full bg-gray-200 text-gray-800 py-2 px-4 rounded hover:bg-gray-300 transition-colors text-sm"
        >
          Cancel
        </button>
      </div>

      <div class="bg-blue-50 border border-blue-200 rounded p-3 text-xs text-blue-700 space-y-2">
        <p class="font-semibold">‚ÑπÔ∏è About X402 Payment Demo:</p>
        <ul class="list-disc list-inside space-y-1">
          <li>Payment request generated by server (402 response)</li>
          <li>"Simulate Payment" creates mock authorization</li>
          <li>Request retried with payment authorization header</li>
          <li>Server validates and returns protected content</li>
        </ul>
        <p class="pt-1 border-t border-blue-200 mt-2">
          <strong>Production flow:</strong> Uses Phantom wallet to sign actual USDC transfer on Solana
        </p>
      </div>
    </div>

    <div v-if="result" class="mt-4 p-4 bg-green-50 border border-green-200 rounded">
      <div class="text-sm font-semibold text-green-800 mb-2">
        ‚úÖ Response:
      </div>
      <pre class="text-xs overflow-auto max-h-48">{{ JSON.stringify(result, null, 2) }}</pre>
    </div>

    <div v-if="error" class="mt-4 p-4 bg-red-50 border border-red-200 rounded">
      <div class="text-sm font-semibold text-red-800 mb-2">‚ùå Error:</div>
      <pre class="text-xs text-red-700 whitespace-pre-wrap overflow-auto max-h-48">{{ error }}</pre>
    </div>
  </div>
</template>

<script setup lang="ts">
import type { PaymentRequestData } from "@openlibx402/core"
import { generateMockPaymentAuthorization } from "~/utils/mock-payment"

const props = defineProps<{
  title: string
  description: string
  endpoint: string
  method?: string
  price: string
  onFetch: (authHeader?: string) => Promise<any>
}>()

const loading = ref(false)
const result = ref<any>(null)
const error = ref<string | null>(null)
const paymentRequired = ref<PaymentRequestData | null>(null)

const handleFetch = async (authHeader?: string) => {
  loading.value = true
  error.value = null
  result.value = null
  paymentRequired.value = null

  try {
    const data = await props.onFetch(authHeader)
    result.value = data
  } catch (err) {
    console.error('Endpoint error:', err)

    // Check if this is a payment required error
    if (err instanceof Error && err.message.includes("Payment Required")) {
      try {
        // Try to parse payment request from error
        const match = err.message.match(/Payment Required: ({[\s\S]*})/)
        if (match) {
          const paymentData = JSON.parse(match[1]) as PaymentRequestData
          paymentRequired.value = paymentData
        }
      } catch (parseErr) {
        // If parsing fails, just show the error
      }
    }

    const errorMsg = err instanceof Error ? err.message : String(err)
    error.value = errorMsg
  } finally {
    loading.value = false
  }
}

const handleSimulatePayment = async () => {
  if (!paymentRequired.value) return

  // Generate mock authorization
  const mockAuth = generateMockPaymentAuthorization(paymentRequired.value)

  loading.value = true
  error.value = null

  // Clear payment required state
  paymentRequired.value = null

  // Retry fetch with mock auth header
  try {
    const data = await props.onFetch(mockAuth)
    result.value = data
  } catch (err) {
    const errorMsg = err instanceof Error ? err.message : String(err)
    error.value = `Payment simulation failed: ${errorMsg}\n\nIn production, this would use your wallet to sign the actual payment transaction.`
  } finally {
    loading.value = false
  }
}

const handleCancel = () => {
  paymentRequired.value = null
  error.value = null
}
</script>
